Best Practices in Java Exception Handling:

1.
  Never swallow the exception in catch block
  
 catch (Exception e) {
   return null;
}

in the above code, it totally shallows the exception and losing the cause of error forver.

2. Include Detailed Stack Trace :
	You should not shallow exceptions or re-throw exceptions without preserving the stack trace.
	Preserving the stack trace when working with exceptions is of most importance to help you debug or troubleshoot your exception properly		
	
	Bad Practice:
	
		try{		
			Set<String> bunchOfAccountNumbers = getAccountNumbersAssociatedToCustomer("userName");
			
		} catch (Exception e){
			// here we are loosing exception stack trace
			throw new RuntimeException();
		}
	
	
	Good Practice:
	
	try{		
			Set<String> bunchOfAccountNumbers = getAccountNumbersAssociatedToCustomer("userName");
			
		} catch (Exception e){
			// here we are preserving original exception instance
			throw new RuntimeException(e);
		}
	

3.Never catch Throwable class

Because java errors are also subclasses of the Throwable. Errors are irreversible conditions that can not be handled by JVM itself. And for some JVM implementations, JVM might not actually even invoke your catch clause on an Error. 

Bad Practice:	
	try {
		/* ... */
	} catch(Throwable t) {
		t.printStackTrace();        
	}
	
4. System.out or System.err should not be used to log exceptions

5.  Validate user input to catch adverse conditions very early in request processing

Always validate user input in very early stage, even before it reached to actual controller. It will help you to minimize the exception handling code in your core application logic. It also helps you in making application consistent if there is some error in user input.

For example: If in account creation  application, you are following below logic:

1) Validate Account Info
2) Insert Account Info
3) Validate address
4) Insert address
5) If problem the Rollback everything

This is very incorrect approach. It can leave you database in inconsistent state in various scenarios. Rather validate everything in first place and then take the user data in dao layer and make DB updates. Correct approach is:

1) Validate Account Info
2) Validate address
3) Insert Account Info
4) Insert address
5) If problem the Rollback everything

6. 6. User defined custom exceptions

Anytime when user feels that he wants to use its own application specific exception for some reasons, he can create a new class extending appropriate super class (mostly its Exception.java) and start using it in appropriate places. 

try {


}catch (Exception e) {
  throw new AccountNotFoundException("Couldn't find account with id " + id, e);
}
Wrapping an exception can provide extra information to the user by adding your own message/ context information, while still preserving the stack trace and message of the original exception.


	
	
